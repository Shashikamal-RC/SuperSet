"""
Module for automating job posting on the Superset platform.
"""
import os
import time
import logging
import platform
from datetime import datetime
from typing import Optional, Dict, List, Union, Any, Tuple
import traceback
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.remote.webelement import WebElement
from selenium.common.exceptions import (
    TimeoutException, 
    NoSuchElementException, 
    ElementNotInteractableException,
    StaleElementReferenceException,
    WebDriverException
)
from selenium.webdriver.chrome.service import Service as ChromeService

# Configure logging with UTF-8 encoding for proper emoji support
logger = logging.getLogger("superset_automator")
logger.setLevel(logging.INFO)

# Clear any existing handlers to prevent duplicate logs
if logger.hasHandlers():
    logger.handlers.clear()

# Create file handler with UTF-8 encoding
file_handler = logging.FileHandler("automation.log", encoding='utf-8')
formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)

# Prevent propagation to root logger to avoid duplicate logs
logger.propagate = False

try:
    # Only import if the module is available
    from webdriver_manager.chrome import ChromeDriverManager
except ImportError:
    logger.warning("webdriver_manager not installed. Will use system ChromeDriver.")


class JobData:
    """
    Container for job posting data.
    """
    
    def __init__(
        self,
        company_name: str,
        job_title: str,
        location: str,
        min_salary: Union[int, str],
        max_salary: Union[int, str],
        job_description: str = "",
        job_function: str = "Product Management",
        salary_breakup: str = "",
        is_ai_generated: bool = False,
        posted_by: str = "",
        timestamp: datetime = None
    ):
        """
        Initialize job data.
        
        Args:
            company_name: Name of the company
            job_title: Job position title
            location: Job location
            min_salary: Minimum salary offered
            max_salary: Maximum salary offered
            job_description: Full job description text
            job_function: Job function/category
            salary_breakup: Details of the salary structure
            is_ai_generated: Whether the job description was generated by AI
            posted_by: Person who posted the job
            timestamp: When the job was posted
        """
        self.company_name = company_name
        self.job_title = job_title
        self.location = location
        self.min_salary = min_salary
        self.max_salary = max_salary
        self.job_description = job_description
        self.job_function = job_function
        self.salary_breakup = salary_breakup
        self.is_ai_generated = is_ai_generated
        self.posted_by = posted_by
        self.timestamp = timestamp or datetime.now()


class ElementInteraction:
    """Helper class for interacting with WebElements."""

    def __init__(self, driver: webdriver.Chrome, wait: WebDriverWait):
        """
        Initialize with WebDriver and WebDriverWait instances.
        
        Args:
            driver: The WebDriver instance
            wait: The WebDriverWait instance
        """
        self.driver = driver
        self.wait = wait
    
    def safe_click(self, element: WebElement) -> bool:
        """
        Try various methods to click an element safely.
        
        Args:
            element: The WebElement to click
            
        Returns:
            True if click was successful, False otherwise
        """
        try:
            # Try normal click
            element.click()
            return True
        except (ElementNotInteractableException, StaleElementReferenceException) as e:
            try:
                # Try JavaScript click
                self.driver.execute_script("arguments[0].click();", element)
                return True
            except Exception as js_error:
                return False
    
    def safe_input(self, element: WebElement, value: str) -> bool:
        """
        Safely input text into an element.
        
        Args:
            element: The WebElement to input text into
            value: The text value to input
            
        Returns:
            True if input was successful, False otherwise
        """
        try:
            element.clear()
            element.send_keys(value)
            return True
        except Exception as e:
            return False
            
    def js_input(self, element: WebElement, value: Union[str, int]) -> bool:
        """
        Input text using JavaScript.
        
        Args:
            element: The WebElement to input text into
            value: The text value to input
            
        Returns:
            True if input was successful, False otherwise
        """
        try:
            self.driver.execute_script(
                "arguments[0].value = arguments[1]", 
                element, 
                str(value)
            )
            return True
        except Exception as e:
            logger.error(f"JavaScript input failed: {e}")
            return False


class SupersetAutomator:
    """
    Automates job posting on the Superset platform.
    
    This class handles login, navigation, and form filling to automate
    the job posting process on the Superset platform.
    """

    def __init__(self, url: str, username: str, password: str, headless: bool = False, 
                 use_remote: bool = False, remote_url: str = "http://localhost:4444/wd/hub"):
        """
        Initialize the Superset automator.
        
        Args:
            url: The URL of the Superset platform
            username: The username for login
            password: The password for login
            headless: Whether to run the browser in headless mode
            use_remote: Whether to use a remote WebDriver setup
            remote_url: URL of the remote WebDriver if use_remote is True
        """
        self.url = url
        self.username = username
        self.password = password
        self.headless = headless
        self.use_remote = use_remote
        self.remote_url = remote_url
        
        # Auto-detect if we're running in a cloud/server environment
        if platform.system() == "Linux" and not os.path.isdir('/home/lenovo'):  # Not on your dev machine
            # Automatically use remote mode in server environments
            self.use_remote = True
            
        self.driver = None
        self.wait = None
        self.element_interaction = None

    def setup_driver(self) -> None:
        """Set up the WebDriver for browser automation."""
        try:
            logger.info("Setting up WebDriver...")
            options = webdriver.ChromeOptions()
            
            # Additional options for better compatibility, especially on Linux servers
            if self.headless:
                options.add_argument("--headless=new")  # Modern headless mode
            options.add_argument("--disable-gpu")
            options.add_argument("--no-sandbox")  # Required for Linux deployments
            options.add_argument("--disable-dev-shm-usage")  # Overcome limited resource problems
            options.add_argument("--disable-extensions")
            options.add_argument("--disable-setuid-sandbox")
            
            # If using remote webdriver (Selenium Grid, Docker, etc.)
            if self.use_remote:
                try:
                    logger.info(f"Using remote WebDriver at {self.remote_url}")
                    self.driver = webdriver.Remote(
                        command_executor=self.remote_url,
                        options=options
                    )
                    logger.info("Remote WebDriver connected successfully")
                except Exception as remote_ex:
                    logger.error(f"Failed to connect to remote WebDriver: {remote_ex}")
                    # If remote fails, fallback to local attempts
                    self.use_remote = False
            
            if not self.use_remote:
                # Local WebDriver setup attempts
                try:
                    # Try with WebDriver manager first
                    try:
                        # Check if ChromeDriverManager is available
                        if 'ChromeDriverManager' in globals():
                            logger.info("Using ChromeDriverManager for setup...")
                            self.driver = webdriver.Chrome(
                                service=ChromeService(ChromeDriverManager().install()), 
                                options=options
                            )
                        else:
                            raise ImportError("ChromeDriverManager not available")
                    except Exception as manager_ex:
                        logger.warning(f"ChromeDriverManager failed: {manager_ex}")
                        
                        # Direct Chrome initialization without service specification
                        logger.info("Trying direct Chrome initialization...")
                        self.driver = webdriver.Chrome(options=options)
                
                except Exception as chrome_ex:
                    logger.error(f"Standard Chrome initialization failed: {chrome_ex}")
                    
                    # Last resort - try specific paths on Linux systems
                    if platform.system() == "Linux":
                        logger.info("Trying Linux-specific ChromeDriver paths...")
                        possible_paths = [
                            '/usr/bin/chromedriver',
                            '/usr/local/bin/chromedriver',
                            '/snap/bin/chromedriver',
                            '/home/appuser/.local/bin/chromedriver'
                        ]
                        
                        for path in possible_paths:
                            if os.path.exists(path):
                                logger.info(f"Found ChromeDriver at: {path}")
                                try:
                                    self.driver = webdriver.Chrome(
                                        service=ChromeService(executable_path=path),
                                        options=options
                                    )
                                    break
                                except Exception as path_ex:
                                    logger.warning(f"Failed with path {path}: {path_ex}")
                        else:
                            # If we get here, none of the paths worked
                            logger.error("Attempting to use Chromium directly")
                            try:
                                # Try using chromium-browser directly
                                options.binary_location = "/usr/bin/chromium-browser"
                                self.driver = webdriver.Chrome(options=options)
                            except Exception as chromium_ex:
                                logger.error(f"Chromium attempt failed: {chromium_ex}")
                                raise Exception("No suitable ChromeDriver found on Linux system")
                    else:
                        # Re-raise the error on non-Linux systems
                        raise chrome_ex
            
            # Setup wait and interaction objects
            self.wait = WebDriverWait(self.driver, 15)
            self.element_interaction = ElementInteraction(self.driver, self.wait)
            logger.info("WebDriver setup completed successfully")
            
        except Exception as e:
            logger.error(f"WebDriver setup failed: {e}")
            # Look for common error patterns and provide more specific error information
            error_str = str(e).lower()
            if "permission denied" in error_str:
                logger.error("Permission issue detected with ChromeDriver. Try: chmod +x /path/to/chromedriver")
            elif "chromedriver" in error_str and "not found" in error_str:
                logger.error("ChromeDriver not found. Install it with: apt-get install -y chromium-chromedriver")
            elif "chrome failed to start" in error_str:
                logger.error("Chrome failed to start. Make sure Chrome is installed: apt-get install -y chromium-browser")
            raise

    def run(self, job_data: JobData) -> bool:
        """
        Run the job posting automation process.
        
        Args:
            job_data: The job data to post
            
        Returns:
            True if job posting was successful, False otherwise
        """
        try:
            self.setup_driver()
            
            # Set an implicit wait for all operations
            if self.driver:
                self.driver.implicitly_wait(5)
                
                try:
                    self.driver.get(self.url)
                    if not self.login():
                        logger.error("Login failed")
                        return False
                        
                    time.sleep(3)  # Wait for dashboard to load
                    
                    # Navigate to the job posting form
                    if not self.navigate_to_job_posting():
                        logger.error("Failed to navigate to job posting form")
                        return False
                        
                    # Fill out and submit the job posting form
                    if not self.fill_job_posting_form(job_data):
                        logger.error("Failed to complete job posting form")
                        return False
                        
                    logger.info(f"Successfully posted job: {job_data.job_title} at {job_data.company_name}")
                    return True
                    
                finally:
                    if self.driver:
                        self.driver.quit()
            else:
                logger.error("Driver setup failed")
                return False
                
        except Exception as e:
            logger.error(f"Unexpected error in automation process: {e}")
            logger.error(traceback.format_exc())
            if self.driver:
                try:
                    # Take screenshot on error for debugging
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    screenshot_path = f"error_screenshot_{timestamp}.png"
                    self.driver.save_screenshot(screenshot_path)
                    logger.info(f"Error screenshot saved to {screenshot_path}")
                except Exception as ss_error:
                    logger.error(f"Failed to capture error screenshot: {ss_error}")
                    
                try:
                    self.driver.quit()
                except Exception:
                    pass
            return False

    def login(self) -> bool:
        """
        Log in to the Superset platform.
        
        Returns:
            True if login was successful, False otherwise
        """
        try:
            # Find and interact with login elements
            # ... rest of the implementation ...
            return True
        except Exception as e:
            logger.error(f"Login error: {e}")
            return False

    def navigate_to_job_posting(self) -> bool:
        """
        Navigate to the job posting form.
        
        Returns:
            True if navigation was successful, False otherwise
        """
        try:
            # Implementation
            return True
        except Exception as e:
            logger.error(f"Navigation error: {e}")
            return False

    def fill_job_posting_form(self, job_data: JobData) -> bool:
        """
        Fill out and submit the job posting form.
        
        Args:
            job_data: The job data to fill in the form
            
        Returns:
            True if form filling and submission were successful, False otherwise
        """
        try:
            # Implementation
            return True
        except Exception as e:
            logger.error(f"Form filling error: {e}")
            return False

# Copy the rest of the implementation from your original file
